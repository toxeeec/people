/**
 * Generated by orval v6.10.3 üç∫
 * Do not edit manually.
 * People API
 * OpenAPI spec version: 1.0.0
 */
import { useQuery, useMutation } from "@tanstack/react-query";
import type {
	UseQueryOptions,
	UseMutationOptions,
	QueryFunction,
	MutationFunction,
	UseQueryResult,
	QueryKey,
} from "@tanstack/react-query";
import type {
	AuthResponse,
	Error,
	AuthUserBodyBody,
	Tokens,
	RefreshTokenBodyBody,
	LogoutBodyBody,
	User,
	Handle,
	DeleteMeBody,
	PostsResponse,
	GetMeFeedParams,
	Users,
	GetMeFollowingParams,
	GetMeFollowersParams,
	GetUsersHandleFollowingParams,
	GetUsersHandleFollowersParams,
	GetUsersSearchParams,
	GetUsersHandlePostsParams,
	GetUsersHandleLikesParams,
	PostResponse,
	NewPostBodyBody,
	GetPostsSearchParams,
	GetPostsPostIDRepliesParams,
	GetPostsPostIDLikesParams,
	ImageResponse,
	ImageBodyBody,
	Thread,
	Messages,
	GetThreadsThreadIDParams,
	Threads,
	GetThreadsParams,
} from "./models";
import { customInstance } from "./custom-instance";
import type { ErrorType } from "./custom-instance";

// eslint-disable-next-line
type SecondParameter<T extends (...args: any) => any> = T extends (
	config: any,
	args: infer P
) => any
	? P
	: never;

export const postRegister = (
	authUserBodyBody: AuthUserBodyBody,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<AuthResponse>(
		{
			url: `/register`,
			method: "post",
			headers: { "Content-Type": "application/json" },
			data: authUserBodyBody,
		},
		options
	);
};

export type PostRegisterMutationResult = NonNullable<
	Awaited<ReturnType<typeof postRegister>>
>;
export type PostRegisterMutationBody = AuthUserBodyBody;
export type PostRegisterMutationError = ErrorType<Error>;

export const usePostRegister = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postRegister>>,
		TError,
		{ data: AuthUserBodyBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postRegister>>,
		{ data: AuthUserBodyBody }
	> = (props) => {
		const { data } = props ?? {};

		return postRegister(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof postRegister>>,
		TError,
		{ data: AuthUserBodyBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const postLogin = (
	authUserBodyBody: AuthUserBodyBody,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<AuthResponse>(
		{
			url: `/login`,
			method: "post",
			headers: { "Content-Type": "application/json" },
			data: authUserBodyBody,
		},
		options
	);
};

export type PostLoginMutationResult = NonNullable<
	Awaited<ReturnType<typeof postLogin>>
>;
export type PostLoginMutationBody = AuthUserBodyBody;
export type PostLoginMutationError = ErrorType<Error>;

export const usePostLogin = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postLogin>>,
		TError,
		{ data: AuthUserBodyBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postLogin>>,
		{ data: AuthUserBodyBody }
	> = (props) => {
		const { data } = props ?? {};

		return postLogin(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof postLogin>>,
		TError,
		{ data: AuthUserBodyBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const postRefresh = (
	refreshTokenBodyBody: RefreshTokenBodyBody,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<Tokens>(
		{
			url: `/refresh`,
			method: "post",
			headers: { "Content-Type": "application/json" },
			data: refreshTokenBodyBody,
		},
		options
	);
};

export type PostRefreshMutationResult = NonNullable<
	Awaited<ReturnType<typeof postRefresh>>
>;
export type PostRefreshMutationBody = RefreshTokenBodyBody;
export type PostRefreshMutationError = ErrorType<Error>;

export const usePostRefresh = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postRefresh>>,
		TError,
		{ data: RefreshTokenBodyBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postRefresh>>,
		{ data: RefreshTokenBodyBody }
	> = (props) => {
		const { data } = props ?? {};

		return postRefresh(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof postRefresh>>,
		TError,
		{ data: RefreshTokenBodyBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const postLogout = (
	logoutBodyBody: LogoutBodyBody,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<void>(
		{
			url: `/logout`,
			method: "post",
			headers: { "Content-Type": "application/json" },
			data: logoutBodyBody,
		},
		options
	);
};

export type PostLogoutMutationResult = NonNullable<
	Awaited<ReturnType<typeof postLogout>>
>;
export type PostLogoutMutationBody = LogoutBodyBody;
export type PostLogoutMutationError = ErrorType<Error>;

export const usePostLogout = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postLogout>>,
		TError,
		{ data: LogoutBodyBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postLogout>>,
		{ data: LogoutBodyBody }
	> = (props) => {
		const { data } = props ?? {};

		return postLogout(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof postLogout>>,
		TError,
		{ data: LogoutBodyBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const putMe = (
	handle: Handle,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<User>(
		{
			url: `/me`,
			method: "put",
			headers: { "Content-Type": "application/json" },
			data: handle,
		},
		options
	);
};

export type PutMeMutationResult = NonNullable<
	Awaited<ReturnType<typeof putMe>>
>;
export type PutMeMutationBody = Handle;
export type PutMeMutationError = ErrorType<Error>;

export const usePutMe = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof putMe>>,
		TError,
		{ data: Handle },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof putMe>>,
		{ data: Handle }
	> = (props) => {
		const { data } = props ?? {};

		return putMe(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof putMe>>,
		TError,
		{ data: Handle },
		TContext
	>(mutationFn, mutationOptions);
};

export const deleteMe = (
	deleteMeBody: DeleteMeBody,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<void>(
		{
			url: `/me`,
			method: "delete",
			headers: { "Content-Type": "application/json" },
			data: deleteMeBody,
		},
		options
	);
};

export type DeleteMeMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteMe>>
>;
export type DeleteMeMutationBody = DeleteMeBody;
export type DeleteMeMutationError = ErrorType<Error>;

export const useDeleteMe = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteMe>>,
		TError,
		{ data: DeleteMeBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteMe>>,
		{ data: DeleteMeBody }
	> = (props) => {
		const { data } = props ?? {};

		return deleteMe(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof deleteMe>>,
		TError,
		{ data: DeleteMeBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const getMeFeed = (
	params?: GetMeFeedParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<PostsResponse>(
		{ url: `/me/feed`, method: "get", params, signal },
		options
	);
};

export const getGetMeFeedQueryKey = (params?: GetMeFeedParams) => [
	`/me/feed`,
	...(params ? [params] : []),
];

export type GetMeFeedQueryResult = NonNullable<
	Awaited<ReturnType<typeof getMeFeed>>
>;
export type GetMeFeedQueryError = ErrorType<unknown>;

export const useGetMeFeed = <
	TData = Awaited<ReturnType<typeof getMeFeed>>,
	TError = ErrorType<unknown>
>(
	params?: GetMeFeedParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getMeFeed>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetMeFeedQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMeFeed>>> = ({
		signal,
	}) => getMeFeed(params, requestOptions, signal);

	const query = useQuery<Awaited<ReturnType<typeof getMeFeed>>, TError, TData>(
		queryKey,
		queryFn,
		{
			refetchOnWindowFocus: false,
			refetchOnMount: false,
			refetchOnReconnect: false,
			retry: 1,
			...queryOptions,
		}
	) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const putMeFollowingHandle = (
	handle: string,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<User>(
		{ url: `/me/following/${handle}`, method: "put" },
		options
	);
};

export type PutMeFollowingHandleMutationResult = NonNullable<
	Awaited<ReturnType<typeof putMeFollowingHandle>>
>;

export type PutMeFollowingHandleMutationError = ErrorType<Error>;

export const usePutMeFollowingHandle = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof putMeFollowingHandle>>,
		TError,
		{ handle: string },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof putMeFollowingHandle>>,
		{ handle: string }
	> = (props) => {
		const { handle } = props ?? {};

		return putMeFollowingHandle(handle, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof putMeFollowingHandle>>,
		TError,
		{ handle: string },
		TContext
	>(mutationFn, mutationOptions);
};

export const deleteMeFollowingHandle = (
	handle: string,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<User>(
		{ url: `/me/following/${handle}`, method: "delete" },
		options
	);
};

export type DeleteMeFollowingHandleMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteMeFollowingHandle>>
>;

export type DeleteMeFollowingHandleMutationError = ErrorType<Error>;

export const useDeleteMeFollowingHandle = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteMeFollowingHandle>>,
		TError,
		{ handle: string },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteMeFollowingHandle>>,
		{ handle: string }
	> = (props) => {
		const { handle } = props ?? {};

		return deleteMeFollowingHandle(handle, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof deleteMeFollowingHandle>>,
		TError,
		{ handle: string },
		TContext
	>(mutationFn, mutationOptions);
};

export const getMeFollowing = (
	params?: GetMeFollowingParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Users>(
		{ url: `/me/following`, method: "get", params, signal },
		options
	);
};

export const getGetMeFollowingQueryKey = (params?: GetMeFollowingParams) => [
	`/me/following`,
	...(params ? [params] : []),
];

export type GetMeFollowingQueryResult = NonNullable<
	Awaited<ReturnType<typeof getMeFollowing>>
>;
export type GetMeFollowingQueryError = ErrorType<Error>;

export const useGetMeFollowing = <
	TData = Awaited<ReturnType<typeof getMeFollowing>>,
	TError = ErrorType<Error>
>(
	params?: GetMeFollowingParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getMeFollowing>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetMeFollowingQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMeFollowing>>> = ({
		signal,
	}) => getMeFollowing(params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getMeFollowing>>,
		TError,
		TData
	>(queryKey, queryFn, {
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getMeFollowers = (
	params?: GetMeFollowersParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Users>(
		{ url: `/me/followers`, method: "get", params, signal },
		options
	);
};

export const getGetMeFollowersQueryKey = (params?: GetMeFollowersParams) => [
	`/me/followers`,
	...(params ? [params] : []),
];

export type GetMeFollowersQueryResult = NonNullable<
	Awaited<ReturnType<typeof getMeFollowers>>
>;
export type GetMeFollowersQueryError = ErrorType<Error>;

export const useGetMeFollowers = <
	TData = Awaited<ReturnType<typeof getMeFollowers>>,
	TError = ErrorType<Error>
>(
	params?: GetMeFollowersParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getMeFollowers>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetMeFollowersQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMeFollowers>>> = ({
		signal,
	}) => getMeFollowers(params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getMeFollowers>>,
		TError,
		TData
	>(queryKey, queryFn, {
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getUsersHandle = (
	handle: string,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<User>(
		{ url: `/users/${handle}`, method: "get", signal },
		options
	);
};

export const getGetUsersHandleQueryKey = (handle: string) => [
	`/users/${handle}`,
];

export type GetUsersHandleQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUsersHandle>>
>;
export type GetUsersHandleQueryError = ErrorType<Error>;

export const useGetUsersHandle = <
	TData = Awaited<ReturnType<typeof getUsersHandle>>,
	TError = ErrorType<Error>
>(
	handle: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getUsersHandle>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetUsersHandleQueryKey(handle);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersHandle>>> = ({
		signal,
	}) => getUsersHandle(handle, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getUsersHandle>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!handle,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getUsersHandleFollowing = (
	handle: string,
	params?: GetUsersHandleFollowingParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Users>(
		{ url: `/users/${handle}/following`, method: "get", params, signal },
		options
	);
};

export const getGetUsersHandleFollowingQueryKey = (
	handle: string,
	params?: GetUsersHandleFollowingParams
) => [`/users/${handle}/following`, ...(params ? [params] : [])];

export type GetUsersHandleFollowingQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUsersHandleFollowing>>
>;
export type GetUsersHandleFollowingQueryError = ErrorType<Error>;

export const useGetUsersHandleFollowing = <
	TData = Awaited<ReturnType<typeof getUsersHandleFollowing>>,
	TError = ErrorType<Error>
>(
	handle: string,
	params?: GetUsersHandleFollowingParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getUsersHandleFollowing>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetUsersHandleFollowingQueryKey(handle, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getUsersHandleFollowing>>
	> = ({ signal }) =>
		getUsersHandleFollowing(handle, params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getUsersHandleFollowing>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!handle,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getUsersHandleFollowers = (
	handle: string,
	params?: GetUsersHandleFollowersParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Users>(
		{ url: `/users/${handle}/followers`, method: "get", params, signal },
		options
	);
};

export const getGetUsersHandleFollowersQueryKey = (
	handle: string,
	params?: GetUsersHandleFollowersParams
) => [`/users/${handle}/followers`, ...(params ? [params] : [])];

export type GetUsersHandleFollowersQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUsersHandleFollowers>>
>;
export type GetUsersHandleFollowersQueryError = ErrorType<Error>;

export const useGetUsersHandleFollowers = <
	TData = Awaited<ReturnType<typeof getUsersHandleFollowers>>,
	TError = ErrorType<Error>
>(
	handle: string,
	params?: GetUsersHandleFollowersParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getUsersHandleFollowers>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGetUsersHandleFollowersQueryKey(handle, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getUsersHandleFollowers>>
	> = ({ signal }) =>
		getUsersHandleFollowers(handle, params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getUsersHandleFollowers>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!handle,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getUsersSearch = (
	params: GetUsersSearchParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Users>(
		{ url: `/users/search`, method: "get", params, signal },
		options
	);
};

export const getGetUsersSearchQueryKey = (params: GetUsersSearchParams) => [
	`/users/search`,
	...(params ? [params] : []),
];

export type GetUsersSearchQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUsersSearch>>
>;
export type GetUsersSearchQueryError = ErrorType<unknown>;

export const useGetUsersSearch = <
	TData = Awaited<ReturnType<typeof getUsersSearch>>,
	TError = ErrorType<unknown>
>(
	params: GetUsersSearchParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getUsersSearch>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetUsersSearchQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersSearch>>> = ({
		signal,
	}) => getUsersSearch(params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getUsersSearch>>,
		TError,
		TData
	>(queryKey, queryFn, {
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getUsersHandlePosts = (
	handle: string,
	params?: GetUsersHandlePostsParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<PostsResponse>(
		{ url: `/users/${handle}/posts`, method: "get", params, signal },
		options
	);
};

export const getGetUsersHandlePostsQueryKey = (
	handle: string,
	params?: GetUsersHandlePostsParams
) => [`/users/${handle}/posts`, ...(params ? [params] : [])];

export type GetUsersHandlePostsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUsersHandlePosts>>
>;
export type GetUsersHandlePostsQueryError = ErrorType<Error>;

export const useGetUsersHandlePosts = <
	TData = Awaited<ReturnType<typeof getUsersHandlePosts>>,
	TError = ErrorType<Error>
>(
	handle: string,
	params?: GetUsersHandlePostsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getUsersHandlePosts>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetUsersHandlePostsQueryKey(handle, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getUsersHandlePosts>>
	> = ({ signal }) =>
		getUsersHandlePosts(handle, params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getUsersHandlePosts>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!handle,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getUsersHandleLikes = (
	handle: string,
	params?: GetUsersHandleLikesParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<PostsResponse>(
		{ url: `/users/${handle}/likes`, method: "get", params, signal },
		options
	);
};

export const getGetUsersHandleLikesQueryKey = (
	handle: string,
	params?: GetUsersHandleLikesParams
) => [`/users/${handle}/likes`, ...(params ? [params] : [])];

export type GetUsersHandleLikesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUsersHandleLikes>>
>;
export type GetUsersHandleLikesQueryError = ErrorType<Error>;

export const useGetUsersHandleLikes = <
	TData = Awaited<ReturnType<typeof getUsersHandleLikes>>,
	TError = ErrorType<Error>
>(
	handle: string,
	params?: GetUsersHandleLikesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getUsersHandleLikes>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetUsersHandleLikesQueryKey(handle, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getUsersHandleLikes>>
	> = ({ signal }) =>
		getUsersHandleLikes(handle, params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getUsersHandleLikes>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!handle,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const postPosts = (
	newPostBodyBody: NewPostBodyBody,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<PostResponse>(
		{
			url: `/posts`,
			method: "post",
			headers: { "Content-Type": "application/json" },
			data: newPostBodyBody,
		},
		options
	);
};

export type PostPostsMutationResult = NonNullable<
	Awaited<ReturnType<typeof postPosts>>
>;
export type PostPostsMutationBody = NewPostBodyBody;
export type PostPostsMutationError = ErrorType<Error>;

export const usePostPosts = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postPosts>>,
		TError,
		{ data: NewPostBodyBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postPosts>>,
		{ data: NewPostBodyBody }
	> = (props) => {
		const { data } = props ?? {};

		return postPosts(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof postPosts>>,
		TError,
		{ data: NewPostBodyBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const getPostsPostID = (
	postID: number,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<PostResponse>(
		{ url: `/posts/${postID}`, method: "get", signal },
		options
	);
};

export const getGetPostsPostIDQueryKey = (postID: number) => [
	`/posts/${postID}`,
];

export type GetPostsPostIDQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPostsPostID>>
>;
export type GetPostsPostIDQueryError = ErrorType<Error>;

export const useGetPostsPostID = <
	TData = Awaited<ReturnType<typeof getPostsPostID>>,
	TError = ErrorType<Error>
>(
	postID: number,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPostsPostID>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetPostsPostIDQueryKey(postID);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostsPostID>>> = ({
		signal,
	}) => getPostsPostID(postID, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getPostsPostID>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!postID,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const deletePostsPostID = (
	postID: number,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<void>(
		{ url: `/posts/${postID}`, method: "delete" },
		options
	);
};

export type DeletePostsPostIDMutationResult = NonNullable<
	Awaited<ReturnType<typeof deletePostsPostID>>
>;

export type DeletePostsPostIDMutationError = ErrorType<unknown>;

export const useDeletePostsPostID = <
	TError = ErrorType<unknown>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deletePostsPostID>>,
		TError,
		{ postID: number },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deletePostsPostID>>,
		{ postID: number }
	> = (props) => {
		const { postID } = props ?? {};

		return deletePostsPostID(postID, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof deletePostsPostID>>,
		TError,
		{ postID: number },
		TContext
	>(mutationFn, mutationOptions);
};

export const getPostsSearch = (
	params: GetPostsSearchParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<PostsResponse>(
		{ url: `/posts/search`, method: "get", params, signal },
		options
	);
};

export const getGetPostsSearchQueryKey = (params: GetPostsSearchParams) => [
	`/posts/search`,
	...(params ? [params] : []),
];

export type GetPostsSearchQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPostsSearch>>
>;
export type GetPostsSearchQueryError = ErrorType<unknown>;

export const useGetPostsSearch = <
	TData = Awaited<ReturnType<typeof getPostsSearch>>,
	TError = ErrorType<unknown>
>(
	params: GetPostsSearchParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPostsSearch>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetPostsSearchQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostsSearch>>> = ({
		signal,
	}) => getPostsSearch(params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getPostsSearch>>,
		TError,
		TData
	>(queryKey, queryFn, {
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getPostsPostIDReplies = (
	postID: number,
	params?: GetPostsPostIDRepliesParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<PostsResponse>(
		{ url: `/posts/${postID}/replies`, method: "get", params, signal },
		options
	);
};

export const getGetPostsPostIDRepliesQueryKey = (
	postID: number,
	params?: GetPostsPostIDRepliesParams
) => [`/posts/${postID}/replies`, ...(params ? [params] : [])];

export type GetPostsPostIDRepliesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPostsPostIDReplies>>
>;
export type GetPostsPostIDRepliesQueryError = ErrorType<unknown>;

export const useGetPostsPostIDReplies = <
	TData = Awaited<ReturnType<typeof getPostsPostIDReplies>>,
	TError = ErrorType<unknown>
>(
	postID: number,
	params?: GetPostsPostIDRepliesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPostsPostIDReplies>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetPostsPostIDRepliesQueryKey(postID, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getPostsPostIDReplies>>
	> = ({ signal }) =>
		getPostsPostIDReplies(postID, params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getPostsPostIDReplies>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!postID,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const postPostsPostIDReplies = (
	postID: number,
	newPostBodyBody: NewPostBodyBody,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<PostResponse>(
		{
			url: `/posts/${postID}/replies`,
			method: "post",
			headers: { "Content-Type": "application/json" },
			data: newPostBodyBody,
		},
		options
	);
};

export type PostPostsPostIDRepliesMutationResult = NonNullable<
	Awaited<ReturnType<typeof postPostsPostIDReplies>>
>;
export type PostPostsPostIDRepliesMutationBody = NewPostBodyBody;
export type PostPostsPostIDRepliesMutationError = ErrorType<Error>;

export const usePostPostsPostIDReplies = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postPostsPostIDReplies>>,
		TError,
		{ postID: number; data: NewPostBodyBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postPostsPostIDReplies>>,
		{ postID: number; data: NewPostBodyBody }
	> = (props) => {
		const { postID, data } = props ?? {};

		return postPostsPostIDReplies(postID, data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof postPostsPostIDReplies>>,
		TError,
		{ postID: number; data: NewPostBodyBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const getPostsPostIDLikes = (
	postID: number,
	params?: GetPostsPostIDLikesParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Users>(
		{ url: `/posts/${postID}/likes`, method: "get", params, signal },
		options
	);
};

export const getGetPostsPostIDLikesQueryKey = (
	postID: number,
	params?: GetPostsPostIDLikesParams
) => [`/posts/${postID}/likes`, ...(params ? [params] : [])];

export type GetPostsPostIDLikesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPostsPostIDLikes>>
>;
export type GetPostsPostIDLikesQueryError = ErrorType<unknown>;

export const useGetPostsPostIDLikes = <
	TData = Awaited<ReturnType<typeof getPostsPostIDLikes>>,
	TError = ErrorType<unknown>
>(
	postID: number,
	params?: GetPostsPostIDLikesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPostsPostIDLikes>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetPostsPostIDLikesQueryKey(postID, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getPostsPostIDLikes>>
	> = ({ signal }) =>
		getPostsPostIDLikes(postID, params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getPostsPostIDLikes>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!postID,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const putPostsPostIDLikes = (
	postID: number,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<PostResponse>(
		{ url: `/posts/${postID}/likes`, method: "put" },
		options
	);
};

export type PutPostsPostIDLikesMutationResult = NonNullable<
	Awaited<ReturnType<typeof putPostsPostIDLikes>>
>;

export type PutPostsPostIDLikesMutationError = ErrorType<Error>;

export const usePutPostsPostIDLikes = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof putPostsPostIDLikes>>,
		TError,
		{ postID: number },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof putPostsPostIDLikes>>,
		{ postID: number }
	> = (props) => {
		const { postID } = props ?? {};

		return putPostsPostIDLikes(postID, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof putPostsPostIDLikes>>,
		TError,
		{ postID: number },
		TContext
	>(mutationFn, mutationOptions);
};

export const deletePostsPostIDLikes = (
	postID: number,
	options?: SecondParameter<typeof customInstance>
) => {
	return customInstance<PostResponse>(
		{ url: `/posts/${postID}/likes`, method: "delete" },
		options
	);
};

export type DeletePostsPostIDLikesMutationResult = NonNullable<
	Awaited<ReturnType<typeof deletePostsPostIDLikes>>
>;

export type DeletePostsPostIDLikesMutationError = ErrorType<Error>;

export const useDeletePostsPostIDLikes = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deletePostsPostIDLikes>>,
		TError,
		{ postID: number },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deletePostsPostIDLikes>>,
		{ postID: number }
	> = (props) => {
		const { postID } = props ?? {};

		return deletePostsPostIDLikes(postID, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof deletePostsPostIDLikes>>,
		TError,
		{ postID: number },
		TContext
	>(mutationFn, mutationOptions);
};

export const postImages = (
	imageBodyBody: ImageBodyBody,
	options?: SecondParameter<typeof customInstance>
) => {
	const formData = new FormData();
	formData.append("image", imageBodyBody.image);

	return customInstance<ImageResponse>(
		{
			url: `/images`,
			method: "post",
			headers: { "Content-Type": "multipart/form-data" },
			data: formData,
		},
		options
	);
};

export type PostImagesMutationResult = NonNullable<
	Awaited<ReturnType<typeof postImages>>
>;
export type PostImagesMutationBody = ImageBodyBody;
export type PostImagesMutationError = ErrorType<Error>;

export const usePostImages = <
	TError = ErrorType<Error>,
	TContext = unknown
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof postImages>>,
		TError,
		{ data: ImageBodyBody },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { mutation: mutationOptions, request: requestOptions } = options ?? {};

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof postImages>>,
		{ data: ImageBodyBody }
	> = (props) => {
		const { data } = props ?? {};

		return postImages(data, requestOptions);
	};

	return useMutation<
		Awaited<ReturnType<typeof postImages>>,
		TError,
		{ data: ImageBodyBody },
		TContext
	>(mutationFn, mutationOptions);
};

export const getUsersHandleThread = (
	handle: string,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Thread>(
		{ url: `/users/${handle}/thread`, method: "get", signal },
		options
	);
};

export const getGetUsersHandleThreadQueryKey = (handle: string) => [
	`/users/${handle}/thread`,
];

export type GetUsersHandleThreadQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUsersHandleThread>>
>;
export type GetUsersHandleThreadQueryError = ErrorType<Error>;

export const useGetUsersHandleThread = <
	TData = Awaited<ReturnType<typeof getUsersHandleThread>>,
	TError = ErrorType<Error>
>(
	handle: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getUsersHandleThread>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetUsersHandleThreadQueryKey(handle);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getUsersHandleThread>>
	> = ({ signal }) => getUsersHandleThread(handle, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getUsersHandleThread>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!handle,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getThreadsThreadID = (
	threadID: number,
	params?: GetThreadsThreadIDParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Messages>(
		{ url: `/threads/${threadID}`, method: "get", params, signal },
		options
	);
};

export const getGetThreadsThreadIDQueryKey = (
	threadID: number,
	params?: GetThreadsThreadIDParams
) => [`/threads/${threadID}`, ...(params ? [params] : [])];

export type GetThreadsThreadIDQueryResult = NonNullable<
	Awaited<ReturnType<typeof getThreadsThreadID>>
>;
export type GetThreadsThreadIDQueryError = ErrorType<Error>;

export const useGetThreadsThreadID = <
	TData = Awaited<ReturnType<typeof getThreadsThreadID>>,
	TError = ErrorType<Error>
>(
	threadID: number,
	params?: GetThreadsThreadIDParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getThreadsThreadID>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetThreadsThreadIDQueryKey(threadID, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getThreadsThreadID>>
	> = ({ signal }) =>
		getThreadsThreadID(threadID, params, requestOptions, signal);

	const query = useQuery<
		Awaited<ReturnType<typeof getThreadsThreadID>>,
		TError,
		TData
	>(queryKey, queryFn, {
		enabled: !!threadID,
		refetchOnWindowFocus: false,
		refetchOnMount: false,
		refetchOnReconnect: false,
		retry: 1,
		...queryOptions,
	}) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};

export const getThreads = (
	params?: GetThreadsParams,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal
) => {
	return customInstance<Threads>(
		{ url: `/threads`, method: "get", params, signal },
		options
	);
};

export const getGetThreadsQueryKey = (params?: GetThreadsParams) => [
	`/threads`,
	...(params ? [params] : []),
];

export type GetThreadsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getThreads>>
>;
export type GetThreadsQueryError = ErrorType<Error>;

export const useGetThreads = <
	TData = Awaited<ReturnType<typeof getThreads>>,
	TError = ErrorType<Error>
>(
	params?: GetThreadsParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getThreads>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customInstance>;
	}
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetThreadsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getThreads>>> = ({
		signal,
	}) => getThreads(params, requestOptions, signal);

	const query = useQuery<Awaited<ReturnType<typeof getThreads>>, TError, TData>(
		queryKey,
		queryFn,
		{
			refetchOnWindowFocus: false,
			refetchOnMount: false,
			refetchOnReconnect: false,
			retry: 1,
			...queryOptions,
		}
	) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

	query.queryKey = queryKey;

	return query;
};
